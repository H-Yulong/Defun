% !TEX root = ../main.tex



\section{Transformation}

This section gives the definition of dependently typed defunctionalization transformation.
The transformation consists of two parts: a transformation $\bbracket{-}$ for terms and a metafunction $\bbracket{-}_d$ that extracts function definitions from the source program. The term transformation produces the target program and the metafunction $\bbracket{-}_d$ gives a label context, which functions similarly to the auxiliary function \textit{apply} in polymorphic defunctionalization.

\subsection{Term transformation}

The term transformation $\bbracket{-}$ turns expressions in CC into expressions in DCC. I define the transformation in with a new judgement of the form $\Gamma \vdash e \goodcolon A \leadsto \target{e}$, and $\bbracket{e} \triangleq \target{e}$. Figure~\ref{fig:dcc transformation} gives the derivation rules of this judgement.

\begin{figure}
	\begin{equation}
		\tag{T-Var}
		\frac
			{}
			{\Gamma \vdash x \goodcolon A \leadsto \target{x}}
	\end{equation} \hspace{0.5cm}
	\begin{equation}
		\tag{T-Universe}
		\frac
			{}
			{\Gamma \vdash U_i \goodcolon U_{i+1} \leadsto \target{U_i}}
	\end{equation} \hspace{0.5cm}
	\begin{equation}
		\tag{T-Pi}
		\frac
			{\Gamma \vdash A \goodcolon U_i \leadsto \target{A} \qquad \Gamma, x \goodcolon A \vdash B \goodcolon U_j \leadsto \target{B}
			}
			{\Gamma \vdash \pitype{x}{A}{B} \mathrel{:} U_{max(i, j)} \leadsto \targetpi{x}{A}{B}}
	\end{equation} \hspace{0.5cm}
	\begin{equation}
		\tag{T-Apply}
		\qquad\qquad\quad
		\frac
			{\Gamma \vdash e_1 \goodcolon \pitype{x}{A}{B} \leadsto \target{e_1} \qquad \Gamma \vdash e_2 \goodcolon A \leadsto \target{e_2}}
			{\Gamma \vdash e_1 \ e_2 \mathrel{:} B\sub{e2}{x} \leadsto \targetapp{e_1}{e_2}}
	\end{equation} \hspace{0.5cm}
	\begin{equation}
		\tag{T-Lambda}
		\qquad\qquad\qquad
		\frac
			{ \text{FV}(\lami{i}{x}{A}{e}) = \bar{x} \goodcolon \bar{A} \qquad \Gamma \vdash \bar{x} \goodcolon \bar{A} \leadsto \target{\bar{x}} }
			{ \Gamma \vdash \lami{i}{x}{A}{e} \mathrel{:} \pitype{x}{A}{B} \leadsto \target{\flabel_i}\{\target{\bar{x}}\}}
	\end{equation} \hspace{0.5cm}
	\begin{equation}
		\tag{T-Equiv}
		\frac
			{\Gamma \vdash e \goodcolon A \leadsto \target{e}}
			{\Gamma \vdash e \goodcolon B \leadsto \target{e}}
	\end{equation}
	\caption{Defunctionalization transformation}
    \label{fig:dcc transformation}
\end{figure}

The term transformation simply transcribes the variables, universes, $\Pi$-types, and applications in CC to their counterparts in DCC. Functions in the source language are translated to labels in the target language. The transformation also turns base types like the natural numbers ($Nat, 0, 1, \cdots$) directly into the corresponding base types in DCC ($\target{Nat}\sfcomma\target{0}\sfcomma\target{1}\cdots$).

Defunctionalization requires a unique correspondence between each label and each source-program function.
I use a convention that every function in the transformation's input $e$ is tagged with a unique identifier $i$ ($i \in \mathbb{N}$), and its corresponding label's name is $\target{\flabel_i}$.

The transformation turns a function $(\lami{i}{x}{A}{e})$ into a label $\targetlab{\flabel_i}{\bar{x}}$, where $\target{\bar{x}}$ come from the function's free variables $\bar{x}$ (T-Lambda). The metafunction FV (see Definition~\ref{def:FV}) computes all free variables and their types involved in a well-typed CC-expression. Note that FV is different from \textit{fv}, the conventional free variable function that computes all the \textit{unbound variables} in an expression. In dependently typed languages, the type of a free variable may contain other free variables, and their types may still contain other free variables, and so on! Therefore, FV$(e)$ should recursively work out all the variables needed for $e$ to be well-typed. 

\begin{definition}FV$(e)$ takes $\Gamma \vdash e \goodcolon A$, the type judgement of $e$, as an implicit argument. It firstly computes all the unbound variables $x_1, \cdots, x_n$ in $e$ and in $A$, then calls itself recursively on types of these variables, and finally returns the union of all free variables and their types it found.
\begin{equation*}
\renewcommand{\arraystretch}{1.3}
\begin{array}{l l l}
	\text{FV}(e) & = & \text{FV}(A_1) \cup \cdots \cup \text{FV}(A_n) \cup \Gamma_{fv}\\
	& \text{where} & \textit{fv }(e) \cup \textit{fv }(A) = x_1, \cdots, x_n\\
	& & \Gamma \vdash x_1 \goodcolon A_1, \cdots, \Gamma \vdash x_n \goodcolon A_n\\
	& & \Gamma_{fv} \triangleq x_1 \goodcolon A_1, \cdots, x_n \goodcolon A_n.\\
\end{array}
\end{equation*}
\label{def:FV}
\end{definition}

Here, the union of two type contexts $\target{\Gamma_1} \cup \target{\Gamma_2}$ is $\target{\Gamma_1}$ appended with all the variable-expression pairs $\itemtype{x}{A}$ that only appear in $\target{\Gamma_2}$ in the order of their apperence. because $e$ is well-typed in $\Gamma$
Since FV($e$) gives all the variables needed to correctly type $e$, if $\Gamma \vdash e : A$ implies that $\text{FV}(e) \vdash e : A$.

\begin{lemma}If $\Gamma \vdash e \goodcolon A$, then $\text{FV}(e) \vdash e \goodcolon A$.
\label{lem:fv}
\end{lemma}


\subsection{Extracting function definitions}

Defunctionalization is not complete with just the transformation -- it turns functions into labels but throws away the function body. The metafunction $\bbracket{-}_d$ takes a CC-expression and returns a label context $\target{\fdef}$.
For every function $(\lami{i}{x}{A}{e})$ in the source program, the following item is in $\target{\fdef}$, where $\{\itemtype{\bar{x}}{\bar{A}}\}$, $\targetpi{x}{A}{B}$, and $\target{e}$ correspond to the free variables $\bar{x} \mathrel{:} \bar{A}$ in $\lambda^i$, the type of $\lambda^i$ and the function body $e$ respectively.
\begin{equation*}
	\itemdef{\target{\flabel_i}}{\itemtype{\bar{x}}{\bar{A}}}{\targetpi{x}{A}{B}}{\target{e}}
\end{equation*}

I define the $\bbracket{-}_d$ with a new judgement of the form $\Gamma \vdash e \goodcolon A \leadsto_d \target{\fdef}$, and $\bbracket{e}_d \triangleq \target{\fdef}$. Figure~\ref{fig:dcc def} gives the derivation rules of this judgement.

\begin{figure}
	\begin{equation}
		\tag{D-Var}
		\frac
			{}
			{\Gamma \vdash x \goodcolon A \leadsto_d \target{\cdot}}
	\end{equation} \vspace{0.5cm}
	\begin{equation}
		\tag{D-Universe}
		\frac
			{}
			{\Gamma \vdash U_i \goodcolon U_{i+1} \leadsto_d \target{\cdot}}
	\end{equation} \vspace{0.5cm}
	\begin{equation}
		\tag{D-Pi}
		\frac
			{\Gamma \vdash A \goodcolon U_i \leadsto_d \target{\fdef_A} \qquad \Gamma, x \goodcolon A \vdash B \goodcolon U_j \leadsto_d \target{\fdef_B}
			}
			{\Gamma \vdash \pitype{x}{A}{B} \mathrel{:} U_{max(i, j)} \leadsto_d \target{\fdef_A} \cup \target{\fdef_B}}
	\end{equation} \vspace{0.5cm}
	\begin{equation}
		\tag{D-Apply}
		\qquad\qquad\quad
		\frac{{\begin{array}{c c}
			  {\Gamma \vdash e_1 \mathrel{:} \pitype{x}{A}{B} \leadsto_d \target{\fdef_1} \qquad \Gamma \vdash e_2 \goodcolon A \leadsto_d \target{\fdef_2}} \\
        	\end{array}}}
			{\Gamma \vdash e_1 \ e_2 \mathrel{:} B\sub{e2}{x} \leadsto_d \target{\fdef_1} \cup \target{\fdef_2}}
	\end{equation} \vspace{0.5cm}
	\begin{equation}
		\tag{D-Lambda}
		\qquad\ \ 
		\frac{{\begin{array}{l @{\qquad} l}
			  \Gamma \vdash A \goodcolon U \leadsto_d \target{\fdef_A} & \Gamma, x \goodcolon A \vdash e \goodcolon B \leadsto_d \target{\fdef_e} \\
			   \text{FV}(\lami{i}{x}{A}{e}) = \bar{x} \goodcolon \bar{A} &
			   \Gamma \vdash \bar{x} \goodcolon \bar{A} \leadsto \itemtype{\bar{x}}{\bar{A}} \\
			   \Gamma \vdash \pitype{x}{A}{B} \leadsto \targetpi{x}{A}{B} &
			   \Gamma, x \goodcolon A \vdash e \leadsto \target{e}\\
        	\end{array}}}
			{\begin{array}{c}
			 \Gamma \vdash \lami{i}{x}{A}{e} \mathrel{:} \pitype{x}{A}{B} \leadsto_d \\
			  \qquad \qquad \qquad \target{\fdef_A} \cup \target{\fdef_e} \sfcomma \itemdef{\target{\flabel_i}}{\itemtype{\bar{x}}{\bar{A}}}{\targetpi{x}{A}{B}}{\target{e}}
			 \end{array}
			}
	\end{equation} \vspace{0.5cm}
	\begin{equation}
		\tag{D-Equiv}
		\qquad\qquad
		\frac
			{\Gamma \vdash e \goodcolon A \leadsto_d \target{\fdef}}
			{\Gamma \vdash e \goodcolon B \leadsto_d \target{\fdef}}
	\end{equation}
	\caption{Extracting function definitions}
    \label{fig:dcc def}
\end{figure}

Variables and universes do not contain function definitions, so $\bbracket{x}_d$ and in $\bbracket{U_i}_d$ returns an empty list (D-Var, D-Universe). Definitions in a dependent function type $\pitype{x}{A}{B}$ are the union of definitions in $A$ and $B$ (D-Pi); similarly, definitions in an application $e_1\ e_2$ are the union of definitions in $e_1$, $e_2$ (D-Apply). 

For a lambda abstraction $\lami{i}{x}{A}{e}$, the definitions it contains are the union of definitions in $e$ and $A$, appended with $\target{\flabel_i}$, the definition of itself (D-Lambda). Function definitions in $e$ do not change when $e$ is typed with $B$ by the conversion rule (D-Equiv).

The term transformation and the process of extracting function definitions ($\bbracket{-}$ and $\bbracket{-}_d$) act pointwise on CC contexts. In other words,
\begin{equation*}
\begin{array}{l @{\qquad} l}
	\bbracket{\cdot}\ \triangleq \target{\cdot}\ , & \bbracket{\Gamma, x \goodcolon A}\ \triangleq \bbracket{\Gamma}\sfcomma \target{x} \goodcolon \bbracket{A},\\
	\bbracket{\cdot}_d \triangleq \target{\cdot}\ , & \bbracket{\Gamma, x \goodcolon A}_d \triangleq \bbracket{\Gamma}_d\cup\bbracket{A}_d,\\
\end{array}
\end{equation*}

Finally, I show an example of dependently typed defunctionalization, which also counts as a piece of empirical evidence that the transformation is type-preserving and correct.

\begin{exmp}Let the source program $p$ be the an application of the polymorphic identity function in CC (see Example 2.2.1), and the lambda abstrctions are tagged with natural numbers.
\begin{align*}
	p &\triangleq (\lami{0}{A}{U_0}{(\lami{1}{x}{A}{x})})\ Nat\ 1\\
	\cdot &\vdash p \mathrel{:} Nat\\
	\cdot &\vdash p\ \triangleright^* 1
\end{align*}
The source program is a function with no free variables appling to the ground type $Nat$ and then to $1$. So, the term transformation is a label supplied with no free-variable values appling to $\target{Nat}$ and then to $\target{1}$.
\begin{equation*}
	\bbracket{p} = 
	\target{Apply}\ \sfpl \target{Apply}\ \targetlab{\flabel_0}{}\ \target{Nat} \sfpr \ \target{1}
\end{equation*}
There are two function definitions ($\lambda^0$ and $\lambda^1$) in the source program. 
Function $\lambda^1$ has one free variable $A$ of type $U_0$; its type is $A \rightarrow A$ and its function body is $x$. 
Function $\lambda^0$ has no free variable; its type is $\pitype{A}{U_0}{A \rightarrow A}$ and its function body is $\lambda^1$ where its free variable $A$ is assigned with the value of the input of $\lambda^0$. Therefore, $\bbracket{p}_d$ returns the following label context with two items.
\begin{align*}
	\target{\fdef} = \target{\cdot}\ \sfcomma\ &\itemdef{\target{\flabel_1}}{\itemtype{A}{U_0}}{\targetpi{x}{A}{A}}{\target{x}}\sfcomma\\
	& \itemdef{\target{\flabel_0}}{}
	{\target{Pi}\textsf{(}\target{A}\sfcomma \target{U_0}\sfcomma \targetpi{x}{A}{A}\textsf{)}}
	{\targetlab{\flabel_1}{A}}
\end{align*}

Next, I verify that the target program $\bbracket{p}$ is indeed well-typed in the DCC context $\bbracket{p}_d \semicolon \target{\cdot}$.

\begin{equation*}
	1 + 1 = 2
\end{equation*}

Since $\cdot \vdash p\ \triangleright^* 1$, we should also have 
$\bbracket{p}_d \semicolon \target{\cdot}\ \vdash\ \bbracket{p}\ \triangleright^* \target{1}$.

\begin{equation*}
	1 + 1 = 2
\end{equation*}
\end{exmp}





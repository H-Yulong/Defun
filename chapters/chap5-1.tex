% !TEX root = ../main.tex

\section{Type preservation and correctness}
As shown in Example 4.3.3, it is not hard to verify that dependently typed defunctionalization produces a well-typed and correct target program for a particular source program. However, type preservation and correctness are difficult to prove in general. Section 5.1.1 explains the problems in proving type preservations directly by induction. Section 5.1.2 establishes an important lemma that leads to type preservation using a helper language (\ccs), and Section 5.1.3 finishes the last steps of the proof.

\subsection{Difficulties in proofs}
In this section, I state the definition of these properties for dependently typed defunctionalization and explain the difficulties in proving them.
For simplicity, I use $\target{e}$ to stand for $\bbracket{e}$ and $\target{\fdef_e}$ to stand for $\bbracket{e}_d$ in this section when there is no ambiguity.

\begin{definition}
Dependently typed defunctionalization is correct if for all ground types $A$ and values $v$ of type $A$,
\begin{equation*}
	\cdot \vdash e \goodcolon A \ \land \
	\cdot \vdash e\ \triangleright^* v\ \Longrightarrow\ 
	\sfpl \target{\fdef_{\Gamma}} \cup \target{\fdef_{e}} \sfpr \semicolon \target{\cdot} \vdash \target{e}\ \triangleright^* \target{v'} \text{ where } \target{v'} \equiv \target{v}.
\end{equation*}
\end{definition}
In other words, if a closed program $e$ evaluates to a ground value $v$, then $\target{e}$ evaluates to a ground value $\target{v'}$ that is equivalent to $\target{v}$.

\begin{definition}
Dependently typed defunctionalization is type-preserving if
\begin{equation*}
	\Gamma \vdash e \goodcolon A \Longrightarrow 
	\sfpl \target{\fdef_{\Gamma}} \cup \target{\fdef_{e}} \cup \target{\fdef_{A}} \sfpr \semicolon \target{\Gamma} \vdash \target{e} \goodcolon \target{A}.
\end{equation*}
\end{definition}
Type preservation states that if the source program has the type $A$ in $\Gamma$, then the target program has the type $\target{A}$ in the DCC context whose type context is $\target{\Gamma}$ and label context is the union of all function definitions that appeared in $\Gamma$, $e$, and $A$. Including $\target{\fdef_A}$ in the label context is necessary because functions may appear in the type of an expression, even if the expression itself does not contain that function! 

For example, consider the following CC context and expression (with base type natural numbers $\mathbb{N}$).
\begin{exmp} I define the context $\Gamma$ and the source program $e$ as follows.
\begin{align*}
	\Gamma\ & \triangleq\ \cdot,\ A \goodcolon (\mathbb{N} \rightarrow \mathbb{N}) \rightarrow U_0,\ 
	a \goodcolon \pitype{f}{(\mathbb{N} \rightarrow \mathbb{N})}{A\ (\lam{n}{\mathbb{N}}{(f\ n) + 1})} \\
	e\ & \triangleq\ a\ (\lam{x}{\mathbb{N}}{x+1})
\end{align*}
$A$ is a family of types indexed by functions of type $\mathbb{N} \rightarrow \mathbb{N}$, and $a\ f$ constructs an element of type $A\ (\lam{n}{\mathbb{N}}{(f\ n) + 1})$. According to the rule (Apply), the type of $e$ is 
\begin{align*}
	& (A\ (\lam{n}{\mathbb{N}}{(f\ n) + 1}))\sub{(\lam{x}{\mathbb{N}}{x+1})}{f}\\
	=\ & A\ (\lam{n}{\mathbb{N}}{((\lam{x}{\mathbb{N}}{x+1})\ n) + 1}).
\end{align*}
A new function definition $(\lam{n}{\mathbb{N}}{((\lam{x}{\mathbb{N}}{x+1})\ n) + 1})$ appeared in the type of $e$ as the result of a substitution.
\label{exp: new type}
\end{exmp}

The essential problem here is that every time a free variable in a function gets substituted by an expression, that function becomes a definitionally different one. If the new function appears in the sub-derivation tree of $\Gamma \vdash e : A$, its definition does not necessarily corresponds to a label recorded in $\sfpl \target{\fdef_{\Gamma}} \cup \target{\fdef_{e}} \cup \target{\fdef_{A}} \sfpr$. This means that I cannot prove type preservation directly by induction on the type derivation rules of CC. For instance, in the case (Equiv), I have

\begin{equation*}
	\frac
	{\Gamma \vdash e : A \qquad \Gamma \vdash B : U \qquad \Gamma \vdash A \equiv B}
	{\Gamma \vdash e : B}
\end{equation*}

and I need to show that 
$\sfpl \target{\fdef_{\Gamma}} \cup \target{\fdef_{e}} \cup \target{\fdef_{B}} \sfpr \semicolon \target{\Gamma} \vdash \target{e} \goodcolon \target{B}$
by DCC's typing rule (Equiv) shown below.
\begin{equation*}
	\frac
	{\target{\fdef}\semicolon \target{\Gamma} \vdash \itemtype{e}{A} \qquad
	 \target{\fdef}\semicolon \target{\Gamma} \vdash \itemtype{B}{U} \qquad
	 \target{\fdef}\semicolon \target{\Gamma} \vdash \target{A} \equiv \target{B}
	}
	{\target{\fdef}\semicolon \target{\Gamma} \vdash \itemtype{e}{B}}
\end{equation*}	
I have 
$\sfpl \target{\fdef_{\Gamma}} \cup \target{\fdef_{e}} \cup \target{\fdef_{A}} \sfpr \semicolon \target{\Gamma} \vdash \target{e} \goodcolon \target{A}$ by the induction hypothesis. 
In order to use (Equiv), I have to show that 
$\sfpl \target{\fdef_{\Gamma}} \cup \target{\fdef_{e}} \cup \target{\fdef_{B}} \sfpr \semicolon \target{\Gamma} \vdash \target{e} \goodcolon \target{A}$, but $\target{A}$ might not even be well-typed in this context!

\subsection{{\ccs} and a key lemma}

Instead of using rule induction directly, I show type preservation with the following lemma.
\begin{lemma} 
For all $\Gamma$, $e$, and $A$, $\Gamma \vdash e : A$ implies that:
\begin{enumerate}
	\item $\sfpl \target{\fdef_{\Gamma}} \cup \target{\fdef_{e}} \sfpr \semicolon \target{\Gamma} \vdash \target{e} \goodcolon \target{T_e}$ for some DCC-expression $\target{T_e}$.
	\item $\sfpl \target{\fdef_{\Gamma}} \cup \target{\fdef_{e}} \cup \target{\fdef_{A}} \sfpr \semicolon \target{\Gamma} \vdash \target{T_e} \equiv \target{A}$
\end{enumerate}
\label{lem: type preservation}
\end{lemma}
By the rule (Equiv) and this lemma, I can obtain type preservation as a corollary. The idea behind the proof of this lemma is the observation that CC's meta-language substitution $(\lam{x}{A}{e_1})\sub{e_2}{y}$ creates a new function definition when it substitutes an expression into a free variables of the function, and this is the only source of creating new function definitions. Therefore, the problem of having new functions by substitutions would not exist if the source language does not evaluate substitutions into functions but keeps them as primitive expressions instead.

To use this observation formally, I define a helper language {\ccs}, which is essentially the source langauge CC with two differences:
\begin{itemize}
	\item Substitution is a part of its syntax instead of a meta-theoretic notion.
	\item It does not evaluate substitutions of expressions into functions.
\end{itemize}

{\ccs} is an extension of CC with new syntax, type derivation rules, reduction rules, and equivalence rules (Figure~\ref{fig: ccs}). I write {\ccs} expressions in a $\helper{blue, mathematical}$ $\helper{font}$ to avoid ambiguity. {\ccs} extends the CC syntax with syntactic \textit{substitutions} of the form $\helper{e_1\sub{e_2}{x}}$ -- note that this is not the usual meta-theoretic substitution, and I emphasised this by colouring the square brackets blue. 

% Type rules
Type rules for variables, universes, $\Pi$-types, functions, and equivalence in {\ccs} are the same as the standard rules in CC.
The type of a substitution $\helper{e_1\sub{e_2}{x}}$ is the type of $\helper{e_1}$ with $\helper{x}$ substituted by $\helper{e_2}$ (\helper{Subst}). The type of an application $\helper{e_1} \ \helper{e_2}$ is $\helper{B\sub{e2}{x}}$ with the syntactic substitution, since there is no meta-language substitution in {\ccs}.

% Reductions and equivalence
{\ccs} has five more reduction rules about substitutions, which are the standard meta-theoretic substitution rules for variables, universes, $\Pi$-types, and applications hard-coded into the language. Note that the substitution in the beta-reduction rule $(\helper{\lambda x} \goodcolon \helper{A} . \helper{e_1})\ \helper{e_2}\ \triangleright\ \helper{e_1\sub{e_2}{x}}$ is also the syntactic one. {\ccs} does not reduce substitutions into functions.

{\ccs} has the standard equivalence rules (\helper{Eq-eq}), (\helper{Eq-Eta1}), and (\helper{Eq-Eta2}), defined in the same way as those rules in are CC. Apart from that, it has two new symmetric rules (\helper{Eq-SubEta1}) and (\helper{Eq-SubEta2}) for determining when a substitution into a function 
$(\helper{\lambda x} \goodcolon \helper{A} . \helper{e})\helper{\sub{e'}{y}}$ 
is equivalent to another expression. This is essentially a variant of the $\eta$-equivalence rules that is compatible with substitutions -- $(\helper{\lambda x} \goodcolon \helper{A} . \helper{e})\helper{\sub{e'}{y}}$ is equivalent to $\helper{e_2}$ if applying $\helper{e_2}$ to $\helper{x}$ is equivalent to the function body $\helper{e}$ with $\helper{y}$ being substituted for $\helper{e'}$.

\begin{figure}
\renewcommand{\arraystretch}{1.3}
	\begin{equation*}
		Expressions \quad ::= \quad \cdots\ |\ \helper{e_1\sub{e_2}{x}} 
	\end{equation*}
	\begin{equation}
		\tag{\helper{Apply}}
		\frac
			{\helper{\Gamma} \vdash \helper{e_1} \goodcolon \helper{\Pi x} \goodcolon \helper{A}. \helper{B} \qquad 
			\helper{\Gamma} \vdash \helper{e_2} \goodcolon \helper{A}}
			{\helper{\Gamma} 	\vdash \helper{e_1} \ \helper{e_2} \goodcolon \helper{B\sub{e2}{x}}}
	\end{equation}
	\begin{equation}
		\tag{\helper{Subst}}
		\frac
			{\helper{\Gamma}, \helper{x} \goodcolon \helper{A} \vdash \helper{e_1} \goodcolon \helper{B} \qquad 
			 \helper{\Gamma} \vdash \helper{e_2} \goodcolon \helper{A}}
			{\helper{\Gamma} \vdash \helper{e_1\sub{e_2}{x}} \goodcolon \helper{B\sub{e2}{x}}}
	\end{equation}
	\begin{align*}
		(\helper{\lambda x} \goodcolon \helper{A} . \helper{e_1})\ \helper{e_2}\ &\triangleright\ \helper{e_1\sub{e_2}{x}}\\
		\helper{x\sub{e}{y}}\ &\triangleright\ \helper{x}\\
		\helper{x\sub{e}{x}}\ &\triangleright\ \helper{e}\\
		\helper{U_i\sub{e}{x}}\ &\triangleright\ \helper{U_i}\\
		(\helper{e_1\ e_2})\helper{\sub{e}{x}}\ &\triangleright\ (\helper{e_1\sub{e}{x}})\ (\helper{e_2\sub{e}{x}}) \\
		(\helper{\Pi x} \goodcolon \helper{A}. \helper{B})\helper{\sub{e}{y}}\ &\triangleright\ 
		\helper{\Pi x} \goodcolon \helper{A\sub{e}{y}}. \helper{B\sub{e}{y}}
	\end{align*}
	\begin{equation}
		\tag{\helper{Eq-SubEta1}}
		\qquad\qquad\qquad
		\frac
			{\begin{array}{l @{\qquad} l}
			\helper{e_1} \triangleright^* (\helper{\lambda x} \goodcolon \helper{A} . \helper{e})\helper{\sub{e'}{y}} &
			 \helper{e_2} \triangleright^* \helper{e_2'}\\
			 \helper{\Gamma}, \helper{x} \goodcolon \helper{A} \vdash \helper{e\sub{e'}{y}} \equiv \helper{e_2'}\ \helper{x}
			 \end{array}
			 }
			{\helper{\Gamma} \vdash \helper{e_1} \equiv \helper{e_2}}
	\end{equation}
	\begin{equation}
		\tag{\helper{Eq-SubEta2}}
		\qquad\qquad\qquad
		\frac
			{\begin{array}{l @{\qquad} l}
			 \helper{e_2} \triangleright^* (\helper{\lambda x} \goodcolon \helper{A} . \helper{e})\helper{\sub{e'}{y}} &
			 \helper{e_1} \triangleright^* \helper{e_1'} \\
			 \helper{\Gamma}, \helper{x} \goodcolon \helper{A} \vdash \helper{e_1'}\ \helper{x} \equiv \helper{e\sub{e'}{y}}
			 \end{array}
			 }
			{\helper{\Gamma} \vdash \helper{e_1} \equiv \helper{e_2}}
	\end{equation}
\label{fig: ccs}
\caption{New syntax and rules in {\ccs}}
\end{figure}


% . It has a syntactic substitution, e1[e2/x], please note that this is NOT THE SAME as the meta-level substitution in CC. The type rule for sub is simple. Subs into anything but functions can be reduced in the standard way as in meta-level substitution, and it has two symmetric extra rules about eta equivalence with substitutions involved.
% Since substitutions into functions never reduce, no new functions pop up in type-checking or in execution!

% Now, I define the transformation from CCs to DCC, which is the transformation from CC to DCC extended with the following two rules:
% 	1. e1[e2/x] --> e1'[e2'/x]
% 	2. e1[e2/x] -->d e1_d U e2_d

% To prove type preservation, I need to show coherence: e1 == e2 implies e1' == e2'.

% To show that, I show firstly the preservation of small step reduction. 
% By definition, I know that the transformation is compatible with substutions (for free!).
% I also know that if e1 >> e2, then e1' >>* e2'. Proof: by induction, every rule except the beta rule are trivial,
% and the beta rule is not that hard.
% It follows directly that e1 >>* e2 implies e1' >>* e2', so the transformation is correct.

% Now coherence. For eq-eq, I get it because of prev. of reduc.
% The second case, proved. Third case, similar.

% Now I have type preservation by a simultenous induction.
% 1. If |- \Gamma then |- [\Gamma]_d ; \Gamma'
% 2. Type preservation

% 1 is easy by induction.
% 2 has some interesting cases.

% Now I am done! The transformation from CCs to DCC is type-preserving and correct!

% Clearly, for all \Gamma \vdash e : A in CC, the translation is the same if we change it directly to DCC,
% or change it to CCs and then to DCC. This shows that the target program is always well-typed.
% The equivalence can be obtained with this property.

% Finally, I show that the transformation is meaning preserving. (Done in induction on ipad).






% Another preferred property of the transformation is the \textit{preservation of reduction sequences}:
% \begin{equation*}
% 	\Gamma \vdash e_1\ \triangleright^* e_2 \Longrightarrow 
% 	\sfpl \target{\fdef_{\Gamma}} \cup \target{\fdef_{e_1}} \cup \target{\fdef_{e_2}} \sfpr \semicolon \target{\cdot} \vdash \target{e_1}\ \triangleright^* \target{e_2}.
% \end{equation*}
% This is the premises for 

\subsection{Final steps}
